#!/usr/bin/env python3
"""
Advanced Web Penetration Testing Tool
Comprehensive OWASP Methodology Implementation

This Flask application provides a comprehensive web interface for conducting
automated penetration testing following OWASP guidelines and best practices.
"""

from flask import Flask, render_template, request, jsonify, send_file
from flask_cors import CORS
import socket
import ssl
import requests
import threading
import time
import json
import xml.etree.ElementTree as ET
from datetime import datetime
import subprocess
import re
import base64
import hashlib
import urllib.parse
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging
from typing import Dict, List, Tuple, Any
import os
import tempfile

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Core vulnerability scanning engine implementing OWASP methodology"""

    def __init__(self):
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (compatible; SecScan/1.0; +http://security-scanner.local)'
        })
        self.vulnerabilities = []
        self.scan_progress = 0
        self.scan_status = "idle"
        self.target_info = {}

    def set_target(self, target: str, ports: List[int] = None):
        """Set scan target and initialize target information"""
        self.target = target
        self.ports = ports or [80, 443, 8080, 8443]
        self.target_info = {
            'target': target,
            'ports': self.ports,
            'timestamp': datetime.now().isoformat()
        }

    def update_progress(self, progress: int, status: str):
        """Update scan progress and status"""
        self.scan_progress = progress
        self.scan_status = status
        logger.info(f"Scan Progress: {progress}% - {status}")

    def port_scan(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Information Gathering
        Perform port scanning to identify open services
        """
        open_ports = []
        self.update_progress(10, "Port Scanning")

        for port in self.ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(3)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    service_info = self.get_service_info(port)
                    open_ports.append({
                        'port': port,
                        'service': service_info['service'],
                        'banner': service_info['banner']
                    })
                sock.close()
            except Exception as e:
                logger.warning(f"Port scan error for {port}: {e}")

        return {
            'open_ports': open_ports,
            'total_tested': len(self.ports)
        }

    def get_service_info(self, port: int) -> Dict[str, str]:
        """Get service information and banner for a specific port"""
        service_map = {
            21: 'FTP', 22: 'SSH', 23: 'Telnet', 25: 'SMTP',
            53: 'DNS', 80: 'HTTP', 110: 'POP3', 143: 'IMAP',
            443: 'HTTPS', 993: 'IMAPS', 995: 'POP3S',
            8080: 'HTTP-Alt', 8443: 'HTTPS-Alt'
        }

        service = service_map.get(port, 'Unknown')
        banner = ""

        try:
            if port in [80, 8080]:
                response = requests.get(f"http://{self.target}:{port}", timeout=5)
                banner = response.headers.get('Server', 'Unknown')
            elif port in [443, 8443]:
                response = requests.get(f"https://{self.target}:{port}", timeout=5, verify=False)
                banner = response.headers.get('Server', 'Unknown')
        except:
            pass

        return {'service': service, 'banner': banner}

    def ssl_tls_analysis(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Cryptographic Issues
        Analyze SSL/TLS configuration for security weaknesses
        """
        self.update_progress(30, "SSL/TLS Analysis")
        ssl_results = {
            'ssl_enabled': False,
            'tls_versions': [],
            'cipher_suites': [],
            'certificate_info': {},
            'vulnerabilities': []
        }

        for port in [443, 8443]:
            try:
                # Test SSL/TLS connection
                context = ssl.create_default_context()
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE

                with socket.create_connection((self.target, port), timeout=10) as sock:
                    with context.wrap_socket(sock, server_hostname=self.target) as ssock:
                        ssl_results['ssl_enabled'] = True
                        ssl_results['tls_versions'].append(ssock.version())
                        ssl_results['cipher_suites'].append(ssock.cipher())

                        # Get certificate information
                        cert = ssock.getpeercert()
                        ssl_results['certificate_info'] = {
                            'subject': dict(x[0] for x in cert['subject']),
                            'issuer': dict(x[0] for x in cert['issuer']),
                            'not_after': cert['notAfter'],
                            'not_before': cert['notBefore']
                        }

                # Check for SSL/TLS vulnerabilities
                self.check_ssl_vulnerabilities(ssl_results)

            except Exception as e:
                logger.warning(f"SSL analysis error for port {port}: {e}")

        return ssl_results

    def check_ssl_vulnerabilities(self, ssl_results: Dict[str, Any]):
        """Check for common SSL/TLS vulnerabilities"""
        # Check for weak TLS versions
        weak_versions = ['SSLv2', 'SSLv3', 'TLSv1.0']
        for version in ssl_results['tls_versions']:
            if any(weak in version for weak in weak_versions):
                self.add_vulnerability(
                    title="Weak TLS Version Detected",
                    severity="medium",
                    owasp_category="A02:2021 – Cryptographic Failures",
                    description=f"Server supports weak TLS version: {version}",
                    location="SSL/TLS Service",
                    recommendation="Disable SSLv2, SSLv3, and TLS 1.0. Use TLS 1.2 or higher."
                )

        # Check certificate expiration
        if ssl_results['certificate_info']:
            not_after = ssl_results['certificate_info']['not_after']
            # Simplified check - in production, parse the date properly
            self.add_vulnerability(
                title="SSL Certificate Analysis",
                severity="info",
                owasp_category="A02:2021 – Cryptographic Failures",
                description=f"SSL certificate expires: {not_after}",
                location="SSL Certificate",
                recommendation="Monitor certificate expiration and renew before expiry."
            )

    def http_security_headers(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Configuration and Deployment Management
        Test for HTTP security headers
        """
        self.update_progress(40, "HTTP Security Headers Analysis")

        security_headers = [
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'X-Frame-Options',
            'X-Content-Type-Options',
            'X-XSS-Protection',
            'Referrer-Policy',
            'Permissions-Policy'
        ]

        results = {
            'present_headers': {},
            'missing_headers': [],
            'vulnerabilities': []
        }

        for port in [80, 443, 8080, 8443]:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                response = requests.get(f"{protocol}://{self.target}:{port}", timeout=10)

                for header in security_headers:
                    if header in response.headers:
                        results['present_headers'][header] = response.headers[header]
                    else:
                        results['missing_headers'].append(header)

                # Check for security vulnerabilities based on missing headers
                self.check_security_headers_vulnerabilities(results['missing_headers'])

                break  # Use first successful connection

            except Exception as e:
                logger.warning(f"Header check error for {protocol}://{self.target}:{port}: {e}")

        return results

    def check_security_headers_vulnerabilities(self, missing_headers: List[str]):
        """Check for vulnerabilities related to missing security headers"""
        header_vulnerabilities = {
            'X-Frame-Options': {
                'title': 'Missing X-Frame-Options Header',
                'severity': 'medium',
                'description': 'Application is vulnerable to clickjacking attacks'
            },
            'Content-Security-Policy': {
                'title': 'Missing Content-Security-Policy Header',
                'severity': 'medium',
                'description': 'Application lacks CSP protection against XSS attacks'
            },
            'Strict-Transport-Security': {
                'title': 'Missing HSTS Header',
                'severity': 'low',
                'description': 'HTTPS connections not enforced via HSTS'
            },
            'X-Content-Type-Options': {
                'title': 'Missing X-Content-Type-Options Header',
                'severity': 'low',
                'description': 'Browser MIME type sniffing not prevented'
            }
        }

        for header in missing_headers:
            if header in header_vulnerabilities:
                vuln = header_vulnerabilities[header]
                self.add_vulnerability(
                    title=vuln['title'],
                    severity=vuln['severity'],
                    owasp_category="A05:2021 – Security Misconfiguration",
                    description=vuln['description'],
                    location="HTTP Headers",
                    recommendation=f"Implement {header} security header"
                )

    def xss_testing(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Input Validation Testing
        Test for Cross-Site Scripting vulnerabilities
        """
        self.update_progress(60, "XSS Vulnerability Testing")

        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//"
        ]

        common_params = ['q', 'search', 'query', 'name', 'input', 'data']

        results = {
            'vulnerable_endpoints': [],
            'tested_payloads': len(xss_payloads),
            'total_tests': 0
        }

        for port in [80, 443, 8080, 8443]:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}"

                for param in common_params:
                    for payload in xss_payloads:
                        try:
                            test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                            response = requests.get(test_url, timeout=5)
                            results['total_tests'] += 1

                            if payload in response.text:
                                results['vulnerable_endpoints'].append({
                                    'url': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'method': 'GET'
                                })

                                self.add_vulnerability(
                                    title="Cross-Site Scripting (XSS) - Reflected",
                                    severity="high",
                                    owasp_category="A03:2021 – Injection",
                                    description=f"Reflected XSS found in parameter '{param}'",
                                    location=f"Parameter: {param}",
                                    recommendation="Implement proper input validation and output encoding"
                                )

                        except Exception as e:
                            logger.debug(f"XSS test error: {e}")

                break  # Use first successful connection

            except Exception as e:
                logger.warning(f"XSS testing error for {protocol}://{self.target}:{port}: {e}")

        return results

    def sql_injection_testing(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Input Validation Testing  
        Test for SQL Injection vulnerabilities
        """
        self.update_progress(70, "SQL Injection Testing")

        sql_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "' OR '1'='1' /*",
            "admin'--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users; --"
        ]

        common_params = ['id', 'user', 'username', 'login', 'email', 'search']

        results = {
            'vulnerable_endpoints': [],
            'tested_payloads': len(sql_payloads),
            'total_tests': 0
        }

        for port in [80, 443, 8080, 8443]:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}"

                for param in common_params:
                    for payload in sql_payloads:
                        try:
                            test_url = f"{base_url}/?{param}={urllib.parse.quote(payload)}"
                            response = requests.get(test_url, timeout=5)
                            results['total_tests'] += 1

                            # Check for SQL error indicators
                            sql_errors = [
                                'sql syntax', 'mysql_fetch', 'ora-', 'microsoft ole db',
                                'unclosed quotation', 'quoted string', 'syntax error'
                            ]

                            response_lower = response.text.lower()
                            if any(error in response_lower for error in sql_errors):
                                results['vulnerable_endpoints'].append({
                                    'url': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'method': 'GET'
                                })

                                self.add_vulnerability(
                                    title="SQL Injection Vulnerability",
                                    severity="high",
                                    owasp_category="A03:2021 – Injection",
                                    description=f"Potential SQL injection in parameter '{param}'",
                                    location=f"Parameter: {param}",
                                    recommendation="Use parameterized queries and input validation"
                                )

                        except Exception as e:
                            logger.debug(f"SQL injection test error: {e}")

                break  # Use first successful connection

            except Exception as e:
                logger.warning(f"SQL injection testing error for {protocol}://{self.target}:{port}: {e}")

        return results

    def csrf_testing(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Session Management Testing
        Test for Cross-Site Request Forgery vulnerabilities
        """
        self.update_progress(80, "CSRF Testing")

        results = {
            'forms_found': 0,
            'csrf_protected': 0,
            'vulnerable_forms': []
        }

        for port in [80, 443, 8080, 8443]:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}"

                response = requests.get(base_url, timeout=10)

                # Simple check for forms without CSRF tokens
                import re
                forms = re.findall(r'<form[^>]*>(.*?)</form>', response.text, re.DOTALL | re.IGNORECASE)
                results['forms_found'] = len(forms)

                for i, form in enumerate(forms):
                    csrf_tokens = ['csrf', 'token', '_token', 'authenticity_token']
                    has_csrf = any(token in form.lower() for token in csrf_tokens)

                    if has_csrf:
                        results['csrf_protected'] += 1
                    else:
                        results['vulnerable_forms'].append(f"Form #{i+1}")

                        self.add_vulnerability(
                            title="Missing CSRF Protection",
                            severity="medium",
                            owasp_category="A01:2021 – Broken Access Control",
                            description=f"Form without CSRF token protection detected",
                            location=f"Form #{i+1}",
                            recommendation="Implement CSRF tokens in all state-changing forms"
                        )

                break  # Use first successful connection

            except Exception as e:
                logger.warning(f"CSRF testing error for {protocol}://{self.target}:{port}: {e}")

        return results

    def directory_enumeration(self) -> Dict[str, Any]:
        """
        OWASP Testing Guide: Information Gathering
        Enumerate directories and files
        """
        self.update_progress(90, "Directory Enumeration")

        common_paths = [
            '/admin', '/administrator', '/login', '/wp-admin', '/phpmyadmin',
            '/backup', '/config', '/test', '/dev', '/api', '/uploads',
            '/images', '/css', '/js', '/includes', '/tmp', '/temp'
        ]

        results = {
            'accessible_paths': [],
            'total_tested': len(common_paths)
        }

        for port in [80, 443, 8080, 8443]:
            try:
                protocol = 'https' if port in [443, 8443] else 'http'
                base_url = f"{protocol}://{self.target}:{port}"

                for path in common_paths:
                    try:
                        test_url = f"{base_url}{path}"
                        response = requests.get(test_url, timeout=5)

                        if response.status_code in [200, 301, 302, 403]:
                            results['accessible_paths'].append({
                                'path': path,
                                'status_code': response.status_code,
                                'size': len(response.content)
                            })

                            if response.status_code == 200 and 'index of' in response.text.lower():
                                self.add_vulnerability(
                                    title="Directory Listing Enabled",
                                    severity="low",
                                    owasp_category="A05:2021 – Security Misconfiguration",
                                    description=f"Directory listing enabled for {path}",
                                    location=path,
                                    recommendation="Disable directory listing and implement proper access controls"
                                )

                    except Exception as e:
                        logger.debug(f"Directory enum error for {path}: {e}")

                break  # Use first successful connection

            except Exception as e:
                logger.warning(f"Directory enumeration error for {protocol}://{self.target}:{port}: {e}")

        return results

    def add_vulnerability(self, title: str, severity: str, owasp_category: str, 
                         description: str, location: str, recommendation: str):
        """Add a vulnerability to the results list"""
        vulnerability = {
            'id': len(self.vulnerabilities) + 1,
            'title': title,
            'severity': severity,
            'owasp_category': owasp_category,
            'description': description,
            'location': location,
            'recommendation': recommendation,
            'timestamp': datetime.now().isoformat()
        }
        self.vulnerabilities.append(vulnerability)

    def comprehensive_scan(self) -> Dict[str, Any]:
        """Run a comprehensive security scan following OWASP methodology"""
        self.vulnerabilities = []
        self.update_progress(0, "Initializing scan")

        results = {
            'scan_info': self.target_info,
            'port_scan': {},
            'ssl_tls': {},
            'http_headers': {},
            'xss_testing': {},
            'sql_injection': {},
            'csrf_testing': {},
            'directory_enum': {},
            'vulnerabilities': []
        }

        try:
            # Execute scan phases
            results['port_scan'] = self.port_scan()
            results['ssl_tls'] = self.ssl_tls_analysis()
            results['http_headers'] = self.http_security_headers()
            results['xss_testing'] = self.xss_testing()
            results['sql_injection'] = self.sql_injection_testing()
            results['csrf_testing'] = self.csrf_testing()
            results['directory_enum'] = self.directory_enumeration()

            # Finalize results
            results['vulnerabilities'] = self.vulnerabilities
            self.update_progress(100, "Scan completed")

        except Exception as e:
            logger.error(f"Scan error: {e}")
            self.update_progress(100, f"Scan failed: {str(e)}")

        return results


# Flask Application
app = Flask(__name__)
CORS(app)

# Global scanner instance
scanner = VulnerabilityScanner()

@app.route('/')
def index():
    """Serve the main application page"""
    return send_file('/home/user/output/advanced_pentest_tool.html')

@app.route('/api/scan', methods=['POST'])
def start_scan():
    """Start a penetration test scan"""
    try:
        data = request.get_json()
        target = data.get('target')
        ports = data.get('ports', [80, 443, 8080, 8443])
        scan_profile = data.get('profile', 'quick')

        if not target:
            return jsonify({'error': 'Target is required'}), 400

        # Set target and start scan in background thread
        scanner.set_target(target, ports)

        def run_scan():
            scanner.comprehensive_scan()

        thread = threading.Thread(target=run_scan)
        thread.daemon = True
        thread.start()

        return jsonify({
            'success': True,
            'message': 'Scan started',
            'scan_id': int(time.time())
        })

    except Exception as e:
        logger.error(f"Scan start error: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/scan/status')
def scan_status():
    """Get current scan status and progress"""
    return jsonify({
        'progress': scanner.scan_progress,
        'status': scanner.scan_status,
        'vulnerabilities_found': len(scanner.vulnerabilities)
    })

@app.route('/api/scan/results')
def scan_results():
    """Get scan results"""
    return jsonify({
        'vulnerabilities': scanner.vulnerabilities,
        'scan_complete': scanner.scan_progress >= 100
    })

@app.route('/api/export/<format>')
def export_results(format):
    """Export scan results in specified format"""
    if not scanner.vulnerabilities:
        return jsonify({'error': 'No scan results available'}), 400

    try:
        if format == 'json':
            return jsonify(scanner.vulnerabilities)
        elif format == 'xml':
            return generate_xml_report()
        elif format == 'csv':
            return generate_csv_report()
        else:
            return jsonify({'error': 'Unsupported format'}), 400
    except Exception as e:
        logger.error(f"Export error: {e}")
        return jsonify({'error': str(e)}), 500

def generate_xml_report():
    """Generate XML report"""
    root = ET.Element("penetration_test_report")

    # Add scan info
    scan_info = ET.SubElement(root, "scan_info")
    ET.SubElement(scan_info, "target").text = scanner.target
    ET.SubElement(scan_info, "timestamp").text = datetime.now().isoformat()

    # Add vulnerabilities
    vulns_element = ET.SubElement(root, "vulnerabilities")
    for vuln in scanner.vulnerabilities:
        vuln_element = ET.SubElement(vulns_element, "vulnerability")
        for key, value in vuln.items():
            ET.SubElement(vuln_element, key).text = str(value)

    xml_str = ET.tostring(root, encoding='unicode')
    return app.response_class(xml_str, mimetype='application/xml')

def generate_csv_report():
    """Generate CSV report"""
    import csv
    import io

    output = io.StringIO()
    writer = csv.writer(output)

    # Write header
    if scanner.vulnerabilities:
        writer.writerow(scanner.vulnerabilities[0].keys())

        # Write data
        for vuln in scanner.vulnerabilities:
            writer.writerow(vuln.values())

    csv_content = output.getvalue()
    output.close()

    return app.response_class(csv_content, mimetype='text/csv')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
